["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/lodash/_composeArgs.js"],"~:js","shadow$provide.module$node_modules$lodash$_composeArgs=function(global,process,require,module,exports,shadow$shims){var nativeMax=Math.max;module.exports=function(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength);for(isCurried=!isCurried;++leftIndex<leftLength;)result[leftIndex]=partials[leftIndex];for(;++argsIndex<holdersLength;)if(isCurried||\nargsIndex<argsLength)result[holders[argsIndex]]=args[argsIndex];for(;rangeLength--;)result[leftIndex++]=args[argsIndex++];return result}}","~:source","shadow$provide[\"module$node_modules$lodash$_composeArgs\"] = function(global,process,require,module,exports,shadow$shims) {\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Creates an array that is the composition of partially applied arguments,\n * placeholders, and provided arguments into a single array of arguments.\n *\n * @private\n * @param {Array} args The provided arguments.\n * @param {Array} partials The arguments to prepend to those provided.\n * @param {Array} holders The `partials` placeholder indexes.\n * @params {boolean} [isCurried] Specify composing for a curried function.\n * @returns {Array} Returns the new array of composed arguments.\n */\nfunction composeArgs(args, partials, holders, isCurried) {\n  var argsIndex = -1,\n      argsLength = args.length,\n      holdersLength = holders.length,\n      leftIndex = -1,\n      leftLength = partials.length,\n      rangeLength = nativeMax(argsLength - holdersLength, 0),\n      result = Array(leftLength + rangeLength),\n      isUncurried = !isCurried;\n\n  while (++leftIndex < leftLength) {\n    result[leftIndex] = partials[leftIndex];\n  }\n  while (++argsIndex < holdersLength) {\n    if (isUncurried || argsIndex < argsLength) {\n      result[holders[argsIndex]] = args[argsIndex];\n    }\n  }\n  while (rangeLength--) {\n    result[leftIndex++] = args[argsIndex++];\n  }\n  return result;\n}\n\nmodule.exports = composeArgs;\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",[]],"~:compiled-at",1537360506100,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$lodash$_composeArgs.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,wCAAA,CAA4D,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,OAAhB,CAAwBC,MAAxB,CAA+BC,OAA/B,CAAuCC,YAAvC,CAAqD,CAEzH,IAAIC,UAAYC,IAAAC,IAqChBL,OAAAC,QAAA,CAxBAK,QAAoB,CAACC,IAAD,CAAOC,QAAP,CAAiBC,OAAjB,CAA0BC,SAA1B,CAAqC,CAAA,IACnDC,UAAa,EADsC,CAEnDC,WAAaL,IAAAM,OAFsC,CAGnDC,cAAgBL,OAAAI,OAHmC,CAInDE,UAAa,EAJsC,CAKnDC,WAAaR,QAAAK,OALsC,CAMnDI,YAAcd,SAAA,CAAUS,UAAV,CAAuBE,aAAvB,CAAsC,CAAtC,CANqC,CAOnDI,OAASC,KAAA,CAAMH,UAAN,CAAmBC,WAAnB,CAGb,KAFIG,SAEJ,CAFkB,CAACV,SAEnB,CAAO,EAAEK,SAAT,CAAqBC,UAArB,CAAA,CACEE,MAAA,CAAOH,SAAP,CAAA,CAAoBP,QAAA,CAASO,SAAT,CAEtB,KAAA,CAAO,EAAEJ,SAAT,CAAqBG,aAArB,CAAA,CACE,GAAIM,SAAJ;AAAmBT,SAAnB,CAA+BC,UAA/B,CACEM,MAAA,CAAOT,OAAA,CAAQE,SAAR,CAAP,CAAA,CAA6BJ,IAAA,CAAKI,SAAL,CAGjC,KAAA,CAAOM,WAAA,EAAP,CAAA,CACEC,MAAA,CAAOH,SAAA,EAAP,CAAA,CAAsBR,IAAA,CAAKI,SAAA,EAAL,CAExB,OAAOO,OArBgD,CAfgE;\",\n\"sources\":[\"node_modules/lodash/_composeArgs.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$lodash$_composeArgs\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/* Built-in method references for those with the same name as other `lodash` methods. */\\nvar nativeMax = Math.max;\\n\\n/**\\n * Creates an array that is the composition of partially applied arguments,\\n * placeholders, and provided arguments into a single array of arguments.\\n *\\n * @private\\n * @param {Array} args The provided arguments.\\n * @param {Array} partials The arguments to prepend to those provided.\\n * @param {Array} holders The `partials` placeholder indexes.\\n * @params {boolean} [isCurried] Specify composing for a curried function.\\n * @returns {Array} Returns the new array of composed arguments.\\n */\\nfunction composeArgs(args, partials, holders, isCurried) {\\n  var argsIndex = -1,\\n      argsLength = args.length,\\n      holdersLength = holders.length,\\n      leftIndex = -1,\\n      leftLength = partials.length,\\n      rangeLength = nativeMax(argsLength - holdersLength, 0),\\n      result = Array(leftLength + rangeLength),\\n      isUncurried = !isCurried;\\n\\n  while (++leftIndex < leftLength) {\\n    result[leftIndex] = partials[leftIndex];\\n  }\\n  while (++argsIndex < holdersLength) {\\n    if (isUncurried || argsIndex < argsLength) {\\n      result[holders[argsIndex]] = args[argsIndex];\\n    }\\n  }\\n  while (rangeLength--) {\\n    result[leftIndex++] = args[argsIndex++];\\n  }\\n  return result;\\n}\\n\\nmodule.exports = composeArgs;\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"nativeMax\",\"Math\",\"max\",\"composeArgs\",\"args\",\"partials\",\"holders\",\"isCurried\",\"argsIndex\",\"argsLength\",\"length\",\"holdersLength\",\"leftIndex\",\"leftLength\",\"rangeLength\",\"result\",\"Array\",\"isUncurried\"]\n}\n"]