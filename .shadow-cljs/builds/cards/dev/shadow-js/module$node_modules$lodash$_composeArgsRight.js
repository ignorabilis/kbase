["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/lodash/_composeArgsRight.js"],"~:js","shadow$provide.module$node_modules$lodash$_composeArgsRight=function(global,process,require,module,exports,shadow$shims){var nativeMax=Math.max;module.exports=function(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength);for(isCurried=!isCurried;++argsIndex<rangeLength;)result[argsIndex]=args[argsIndex];for(rangeLength=\nargsIndex;++rightIndex<rightLength;)result[rangeLength+rightIndex]=partials[rightIndex];for(;++holdersIndex<holdersLength;)if(isCurried||argsIndex<argsLength)result[rangeLength+holders[holdersIndex]]=args[argsIndex++];return result}}","~:source","shadow$provide[\"module$node_modules$lodash$_composeArgsRight\"] = function(global,process,require,module,exports,shadow$shims) {\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * This function is like `composeArgs` except that the arguments composition\n * is tailored for `_.partialRight`.\n *\n * @private\n * @param {Array} args The provided arguments.\n * @param {Array} partials The arguments to append to those provided.\n * @param {Array} holders The `partials` placeholder indexes.\n * @params {boolean} [isCurried] Specify composing for a curried function.\n * @returns {Array} Returns the new array of composed arguments.\n */\nfunction composeArgsRight(args, partials, holders, isCurried) {\n  var argsIndex = -1,\n      argsLength = args.length,\n      holdersIndex = -1,\n      holdersLength = holders.length,\n      rightIndex = -1,\n      rightLength = partials.length,\n      rangeLength = nativeMax(argsLength - holdersLength, 0),\n      result = Array(rangeLength + rightLength),\n      isUncurried = !isCurried;\n\n  while (++argsIndex < rangeLength) {\n    result[argsIndex] = args[argsIndex];\n  }\n  var offset = argsIndex;\n  while (++rightIndex < rightLength) {\n    result[offset + rightIndex] = partials[rightIndex];\n  }\n  while (++holdersIndex < holdersLength) {\n    if (isUncurried || argsIndex < argsLength) {\n      result[offset + holders[holdersIndex]] = args[argsIndex++];\n    }\n  }\n  return result;\n}\n\nmodule.exports = composeArgsRight;\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",[]],"~:compiled-at",1537360506100,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$lodash$_composeArgsRight.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,6CAAA,CAAiE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,OAAhB,CAAwBC,MAAxB,CAA+BC,OAA/B,CAAuCC,YAAvC,CAAqD,CAE9H,IAAIC,UAAYC,IAAAC,IAuChBL,OAAAC,QAAA,CA1BAK,QAAyB,CAACC,IAAD,CAAOC,QAAP,CAAiBC,OAAjB,CAA0BC,SAA1B,CAAqC,CAAA,IACxDC,UAAa,EAD2C,CAExDC,WAAaL,IAAAM,OAF2C,CAGxDC,aAAgB,EAHwC,CAIxDC,cAAgBN,OAAAI,OAJwC,CAKxDG,WAAc,EAL0C,CAMxDC,YAAcT,QAAAK,OAN0C,CAOxDK,YAAcf,SAAA,CAAUS,UAAV,CAAuBG,aAAvB,CAAsC,CAAtC,CAP0C,CAQxDI,OAASC,KAAA,CAAMF,WAAN,CAAoBD,WAApB,CAGb,KAFII,SAEJ,CAFkB,CAACX,SAEnB,CAAO,EAAEC,SAAT,CAAqBO,WAArB,CAAA,CACEC,MAAA,CAAOR,SAAP,CAAA,CAAoBJ,IAAA,CAAKI,SAAL,CAGtB,KADIW,WACJ;AADaX,SACb,CAAO,EAAEK,UAAT,CAAsBC,WAAtB,CAAA,CACEE,MAAA,CAAOG,WAAP,CAAgBN,UAAhB,CAAA,CAA8BR,QAAA,CAASQ,UAAT,CAEhC,KAAA,CAAO,EAAEF,YAAT,CAAwBC,aAAxB,CAAA,CACE,GAAIM,SAAJ,EAAmBV,SAAnB,CAA+BC,UAA/B,CACEO,MAAA,CAAOG,WAAP,CAAgBb,OAAA,CAAQK,YAAR,CAAhB,CAAA,CAAyCP,IAAA,CAAKI,SAAA,EAAL,CAG7C,OAAOQ,OAvBqD,CAfgE;\",\n\"sources\":[\"node_modules/lodash/_composeArgsRight.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$lodash$_composeArgsRight\\\"] = function(global,process,require,module,exports,shadow$shims) {\\n/* Built-in method references for those with the same name as other `lodash` methods. */\\nvar nativeMax = Math.max;\\n\\n/**\\n * This function is like `composeArgs` except that the arguments composition\\n * is tailored for `_.partialRight`.\\n *\\n * @private\\n * @param {Array} args The provided arguments.\\n * @param {Array} partials The arguments to append to those provided.\\n * @param {Array} holders The `partials` placeholder indexes.\\n * @params {boolean} [isCurried] Specify composing for a curried function.\\n * @returns {Array} Returns the new array of composed arguments.\\n */\\nfunction composeArgsRight(args, partials, holders, isCurried) {\\n  var argsIndex = -1,\\n      argsLength = args.length,\\n      holdersIndex = -1,\\n      holdersLength = holders.length,\\n      rightIndex = -1,\\n      rightLength = partials.length,\\n      rangeLength = nativeMax(argsLength - holdersLength, 0),\\n      result = Array(rangeLength + rightLength),\\n      isUncurried = !isCurried;\\n\\n  while (++argsIndex < rangeLength) {\\n    result[argsIndex] = args[argsIndex];\\n  }\\n  var offset = argsIndex;\\n  while (++rightIndex < rightLength) {\\n    result[offset + rightIndex] = partials[rightIndex];\\n  }\\n  while (++holdersIndex < holdersLength) {\\n    if (isUncurried || argsIndex < argsLength) {\\n      result[offset + holders[holdersIndex]] = args[argsIndex++];\\n    }\\n  }\\n  return result;\\n}\\n\\nmodule.exports = composeArgsRight;\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"process\",\"require\",\"module\",\"exports\",\"shadow$shims\",\"nativeMax\",\"Math\",\"max\",\"composeArgsRight\",\"args\",\"partials\",\"holders\",\"isCurried\",\"argsIndex\",\"argsLength\",\"length\",\"holdersIndex\",\"holdersLength\",\"rightIndex\",\"rightLength\",\"rangeLength\",\"result\",\"Array\",\"isUncurried\",\"offset\"]\n}\n"]